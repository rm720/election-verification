\chapter{Introduction}\label{chap:introduction}
\section{Election}
The election process is a critical component of democracy. 
However, traditional paper voting faces numerous challenges. 
Voting and tallying are labor-intensive, the vote counting process is not 
transparent, audit is not available for the general public, and the process 
does not scale well. As society advances rapidly, our democratic processes must 
adapt to meet new demands. Electronic voting provides the benefits of automation 
and online access; however, it introduces its own set of problems. Since electronic 
voting relies on software, it inherently contains errors, which can be difficult to 
eliminate entirely \cite{brooks1975mythical}. Fixing one issue often introduces another. 
Numerous instances of errors in electronic voting have been 
documented \cite{ChangFong2016TheCS, Halderman2015TheNS, Haines2022RunningTR}. 
Such errors undermine public trust in the electoral process. Given the importance 
of elections, we cannot tolerate more than zero errors in the election process. 
Therefore, if we want to employ electronic voting, it is crucial to provide a 
zero-error guarantee in electronic voting software for it to be considered both 
reliable and trustworthy.
\section{Software} 
To ensure an error-free election, it is vital to provide the same guarantee 
for the software conducting the voting. Software errors are common, mainly 
because the development process inherently doesn't guarantee correctness. 
Historically, there is a gap \label{gap} between the theoretical correctness 
and the actual operation of the software. The industry standard for ensuring 
operational correctness is through testing, but this method only identifies 
existing errors and cannot assure their complete absence. A more effective, 
though less frequently used, method is a formal proof of the program code or 
algorithm. Regrettably, this proof is often conducted separately from the compiled 
code, either on paper or within a proof assistant environment, resulting in a gap 
between theory and practice. This separation occurs largely due to two 
factors: (1) programming languages are not typically designed for proof 
writing; (2) compilers, which have been found to contain 
errors \cite{Yang2011FindingAU}, are not purposed to maintain code 
correctness. Therefore, software industry is not yet mature enough 
to satisfy high requirements for electronic election.
\section{Cryptography}
Electronic election employ cryptography to protect the process and 
information from unauthorised intervention. The use of cryptography 
in electronic voting systems introduces an additional source of complexity, 
thereby increasing the potential for errors. The cryptographic techniques 
employed in these systems are based on sigma protocol technology and abstract 
algebra theories. Given their non-trivial nature, even a minor mistake could 
significantly compromise an election. There are well-documented 
cases \cite{Halderman2015TheNS, Springall2014SecurityAO, Haines2022RunningTR}, where 
cryptographic errors have resulted in exploitable vulnerabilities in electronic election. 
For example, a minor flaw could enable an election official to covertly alter votes, as 
demonstrated in a case involving the SwissVote 
election 
system\footnote{https://www.unimelb.edu.au/newsroom/news/2019/march/researchers-find-trapdoor-in-swissvote-election-system}. 
The combination of complexity of cryptographic techniques and the inherent difficulty 
in ensuring software accuracy makes the task of implementing error-free electronic voting exceedingly challenging.
\section{Election Verification} 
Electronic voting has the potential to enhance democratic elections, 
but the trustworthiness of electronic voting is currently in question 
due to inability to guarantee absence of errors. There is a partial solution to this problem. 

Electronic elections perform  cryptographic computation producing encrypted data. This data can be used to 
verify computation posterior to the election and guarantee certain properties of election to hold. The 
verification program, functioning independently once the election is completed, is smaller and less 
complex than the electronic election system, as it isolates properties and does no interaction. Less 
complex programs of smaller sizes are typically less susceptible to errors, consequently providing a 
greater degree of certainty in their absence. 

In order to be able to rely on such verification we can formally prove that the code of this small 
verifying program has no errors and does what it supposed to do, however, as discussed earlier, the 
environment where we develop the proof and compiler are also computer programs containing errors. 
There is no guarantee that such errors do not propagate cause election with errors be positively verified.
\section{Problem} 
As discussed above, ensuring that the required properties of electronic elections are met is an 
extremely challenging task. However, this is a crucial requirement for electronic elections to be 
considered trustworthy. The goal of our research is to improve the current situation by addressing 
these challenges.
\section{Solution}
A potential solution to this problem is to use such proof environment and compiler that guarantee 
to produce valid proofs and correctly operating executable program, to develop election verification 
program that is guaranteed to have no errors. Then, employ such verification programs to verify required properties of electronic election one by one. Using such approach all required properties of electronic election can be guaranteed. This process can ensure that a given election is error-free.

Unfortunately, the above conceptual approach is not widely practiced, possibly due to lack of 
information and detailed guidelines to follow. The solution we propose is a generalised 
technique that demonstrate an example for how to develop such  election verification program 
for some selected properties of electronic election and use it to verify election to guarantee that electronic election comply with some target property. Our proposed technique will help developers to rely on the above concept and guarantee certain properties of electronic election to hold.
\section{Contribution}
Our contribution is an improvement to the previously developed similar 
technique \cite{Haines2019VerifiableHT}. A particular improvement that we make, 
is joining the gap in correctness of election verification program from the code 
to the operational program. We achieve it by employing (1) a theorem proof environment 
that is verified to accept only valid poofs, and (2) a compiler that is guaranteed to 
produce executable program which behaves precisely as it code specifies. 
