\chapter{Conclusion}
In this thesis, we have worked on bridging the gap in software correctness for electronic election verifiers by building upon prior work. We presented an improvement to a technique for constructing electronic election verifiers. This contribution advances the field of electronic elections, providing greater trustworthiness and transparency through the improved correctness of election verifiers. Additionally, this study contributes to proof-based software development by practicing application of verified tools like HOL4 and CakeML in considerable projects such as this one. Throughout this project, we encountered a mix of successes and challenges, thereby accruing substantial knowledge, which holds relevance to both research and development in the electronic election and proof-based development domains. While our research marks a significant stride forward, there are potential avenues for future exploration and limitations to acknowledge.

\section{Limitations}
\subsubsection{Operational program}
Our work does not include compiled of the executable program of election verifier, therefore, We did not apply our extended technique to a real election verification. The reason for such limitation is that Helios public evidence data is represented by a JSON file, and, unfortunately, the CakeML programming language is not capable of reading JSON files, the required library simply have not been developed yet. CakeML is not a product but rather a work in progress, and we hope that such a library will be developed soon, so we can use it to compile compilation to run a demonstration of our verifier. To be precise, absence of JSON reading libraries does not prevent compilation of our election verifier however, It prevent running the compiled program on any election data that it have been designed for. Therefore, the trial of verification of real electiotn is suspended until JSON reading libarry is released. We concluded our project at delivering verified code for election verifier, because there not much value in obtaining executable program of election verifier that is unable to ingest input data. This limitation is a development opportunity for future work.

\subsubsection{Sigma Protocol}
The Sigma Protocol we constructed (combinational compositions of Schnorr Sigma Protocol) for the use of the Honest Verifier is not identical but rather equivalent to the actual protocol used in Helios electronic election . While it may not be immediately obvious to some readers, it suffices to use the acceptance of the transcript by the Honest Verifier of the equivalent Sigma Protocol as a guarantee of election integrity. We used the Disjunction of Equivalence of Schnorr Sigma Protocol to model Helios Election which uses the Chaum-Pedersen Sigma Protocol.  Although the two protocols perform essentially equivalent computations and are fundamentally equivalent, our work lacks a formal proof that establish this connection. To address this discrepancy and enhance the rigor of our work, it would be beneficial to consider introducing a proof to bridge this minor yet potentially significant gap.
 While this equivalence of Sigma Protocols might need a formal proof, we refer to \cite{Haines2019VerifiedVF}, where they performed analogous manipulation and verified a Helios-based election with a similar combination of Sigma Protocols.

\subsubsection{Non-Interactive Sigma Protocol}
Important to understand, that Helios Voting uses non-interactive version of the Sigma Protocol, while all our proofs of theorems from definition refer to interactive Sigma Protocols. The reason why this discrepancy does not cause a problem is the following. The transcript for interactive and non-interactive protocols cannot be distinguished. In the non-interactive protocol, parties use the same hash function to compute the challenge, so instead of having a Verifier sending a challenge, the Prover just computes it by itself. Produced transcript is the same as if Verifier would have computed challenge using hash function and send to Prover. Therefore there is not difference for the proofs. Here, we also can refer to \cite{Haines2019VerifiedVF}, who performed such verification of election, using the same thoerems defined for interactive Sigma Protocols and verified Helios based election, which uses non-interactive election protocol. Despite this descrepancy does not cause a problem, mathematically it is break in the correctness proof. If we want to achieve absolutely clean and connected proof of correctness of election verifier, we might want to provide a formal proof.

\subsubsection{Results of Election Verifier}
It is crucial to recognise that our election verifeir is only able to confirm that integrity property hold for an election, it is unable to confirm a fraud or bogus election. If the election verifier returns negative result, it does not necessarily mean that the election is bogus. Instead, it means that further investigation is required to locate the cause. This is a serious limitation from a usability point of view. For example, if a verifier returns negative result for an important real election. The investigation can take a long time and there is no guarantee that error will be eventually located. Finding and fixing the error and then running the verifier again to obtain a positive result may not look good for the public. The election conducting authority needs to decide whether to rerun the election or not. When costs are involved, it is crucial to have a clear result. However, this is not only a problem with our development of a verifier. This is a general limitation of election verification software.

\section{Future Work}
\subsubsection{More Comprehensive Verification}
We have extended the technique aimed at developing a verifier for a universally verifiable subset of integrity properties, which are limited in number and value. We have excluded individually verifiable properties and privacy property completely from our verification. Such choice make sense, since we only presented a demonstration of the technique. When it comes to guaranteeing election correctness, we need a higher degree of certainty than just three properties. Therefore, it may be useful to consider implementing a more comprehensive election verifier to contribute to actual real deployed electronic elections.

\subsubsection{Technique validation}
Given that our primary objective was to develop a technique rather than 
constructing a proven verifier, it could be valuable to perform extensive 
validation pf this technique by employing it for the development of verifiers 
of other types of elections. This could include more complex elections, simulated 
elections, or elections facilitated on different platforms, such as Belenios\footnote{https://www.belenios.org}. This approach would not only bolster our confidence in the technique but also potentially uncover any existing limitations, thereby prompting further enhancements.

\subsubsection{Democratising}
HOL and CakeML, while powerful, have not gained widespread popularity, primarily due to the complexity and steep learning curve. To ensure our technique is readily adopted by developers and bring benefits to the industry, we might contemplate creating a user-friendly interface with popular programming languages, like Java or Python. Not only would this enhance the accessibility of our technique, but it could also help promote the broader adoption of proof-based development.